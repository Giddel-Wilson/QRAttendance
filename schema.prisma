generator client {
provider = "prisma-client-js"
}

datasource db {
provider = "postgresql"
url = env("POSTGRES_PRISMA_URL")
directUrl = env("POSTGRES_URL_NON_POOLING")
}

model User {
id String @id @default(uuid())
email String @unique
passwordHash String
name String?
role String @default("STUDENT")
department String?
matricNumber String? // Add this field for matriculation number
level String? // Add this field for academic level
createdAt DateTime @default(now())
updatedAt DateTime @updatedAt

// Change from direct Course relation to many-to-many
taughtCourses CourseLecturer[]
attendances Attendance[] @relation("UserToAttendance")
enrolledCourses StudentCourse[]

// FIXED: Keep only these two correctly named relations
createdNotifications Notification[] @relation("UserToNotifications")
userNotifications UserNotification[] @relation("UserToUserNotifications")
}

model Course {
id String @id @default(uuid())
code String @unique
name String
description String?
department String?
semester String? @default("FIRST")
// Remove the direct lecturerId field
// lecturerId String?
createdAt DateTime @default(now())
updatedAt DateTime @updatedAt

// Change from direct User relation to many-to-many
lecturers CourseLecturer[]
schedules Schedule[]
sessions Session[]
students StudentCourse[]
}

// New model for the many-to-many relationship
model CourseLecturer {
id String @id @default(uuid())
courseId String
lecturerId String
assignedAt DateTime @default(now())

course Course @relation(fields: [courseId], references: [id])
lecturer User @relation(fields: [lecturerId], references: [id])

@@unique([courseId, lecturerId])
}

model StudentCourse {
id String @id @default(uuid())
studentId String
courseId String
enrolledAt DateTime @default(now())

student User @relation(fields: [studentId], references: [id])
course Course @relation(fields: [courseId], references: [id])

@@unique([studentId, courseId])
}

model Schedule {
id String @id @default(uuid())
courseId String
dayOfWeek Int
startTime String
endTime String
location String?
createdAt DateTime @default(now())
updatedAt DateTime @default(now())

course Course @relation(fields: [courseId], references: [id])
}

model Session {
id String @id @default(uuid())
courseId String
date DateTime
title String?
topic String?
notes String?
createdAt DateTime @default(now())
updatedAt DateTime @default(now())

course Course @relation(fields: [courseId], references: [id])
attendances Attendance[]
}

model Attendance {
id String @id @default(uuid())
userId String
sessionId String
status String
timestamp DateTime @default(now())
notes String?

user User @relation("UserToAttendance", fields: [userId], references: [id])
session Session @relation(fields: [sessionId], references: [id])

@@unique([userId, sessionId])
}

// Add these new models at the end
model Notification {
id String @id @default(uuid())
title String
message String
targetRole String @default("ALL")
createdAt DateTime @default(now())
createdBy String?
creator User? @relation("UserToNotifications", fields: [createdBy], references: [id])
userNotifications UserNotification[]
}

model UserNotification {
id String @id @default(uuid())
userId String
notificationId String
read Boolean @default(false)
readAt DateTime?
createdAt DateTime @default(now())

user User @relation("UserToUserNotifications", fields: [userId], references: [id], onDelete: Cascade)
notification Notification @relation(fields: [notificationId], references: [id], onDelete: Cascade)

@@unique([userId, notificationId])
}
